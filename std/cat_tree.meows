~( ^.x.^)> -----------------------------------------------
An implementation of lazy sequence function application.

It's inspired by C#'s LINQ!

-- Cat Trees (Iterator) --
They provide an interface for interating over a collection
or otherwise iteratable object.

They contain three core items:
1. 'current'    -> The 'current' item.
2. 'next()'     -> A method that moves to the next item.
3. 'rewind()'   -> Rewinds the iterator to its initial state.

The cat_tree() function takes three arguments:
1. An initial state value.
2. A 'state' value. It can be anything.
3. An iterator function. It should return a value that'll
be used as the new 'current' value each time .next() is
called.

All of those arguments are deep-copied.

The iterator function can manipulate the home.state field
if it wishes.

The cat_tree() function produces a rewind() function behind
the scenes that sets home.current and home.state to the
1st and 2nd arguments passed to the function.



-- [to name] --
[to name] provide an interface for lazily performing queued
operations over an iterator's values.

Every call of '.where()', '.choose()' and other methods add
a new function to the bottom of the queue.

In each call of .next(), the [to_name] asks for another item
from the iterator and lazily applies the queued functions
to the item. When the iterator is out of items, iteration
ends, and .next() returns lonely.

**Note:** While iterators start at the first item and each
call of .next() moves them further along, a [to_name]
always starts *before* the first item. Thus, the first call
of .next() will give you the *first* element.

If all catfunctions return happy, the [to_name] returns the
item and stops. If not, the [to_name] asks for another item
and repeats the process.

The .to_shelf() method will always traverse the iterator's 
values only once, no matter how many functions are in the
queue.
**Note:** The .to_shelf() function **will hang** when given
an infinite iteratable.

The .pick(x) method will only ask for x items, no matter how
many items the iterator is able to produce. The functions in
the queue will, thus, only be applied to exactly x items.

The .rewind() method rewinds the iterator. It does **not**
clean the function queue.

The .reset() method rewinds the iterator *and* cleans the
[to_name]'s function queue.


The [to_name] function takes one argument, an iterator box,
which it **always deep-copies.**
----------------------------------------------- <(^.x.^ )~

takes "std.meows" as std

=^.x.^= cat_tree (init, state, iterator)

    =^.x.^= rewind ()
        home.state = copy(state)
        home.current = copy(init)
    meow meow

    =^.x.^= next ()
        home.current = home.iterator()
        bring home.current
    meow meow

    =^.x.^= to_shelf ()
        mew output = []
        meowmeow (home.current)
            home.current push output
            home.next()
        meow meow
        bring reverse(output)
    meow meow

    =^.x.^= pick (n)
        mew output = []
        mew i = 0
        meowmeow (home.current and i < n)
            home.current push output
            home.next()
            paw at i
        meow meow
        bring reverse(output)
    meow meow

    bring ~( ^.x.^) BOX!! [
        current:    copy(init),
        state:      copy(state),
        iterator:   copy(iterator),
        next:       next,
        rewind:     rewind,
        to_shelf:   to_shelf,
        pick:       pick
    ]
meow meow


=^.x.^= to_name (i)

    mew queue = []
    mew itr = copy(i)

    =^.x.^= where (fn)
        bring itr.current and fn(itr.current)
    meow meow

    =^.x.^= choose (fn)
        mew? (not itr.current)
            bring sad
        meow meow
        itr.current = fn(itr.current)
        bring happy
    meow meow

    =^.x.^= enqueue (queued_func, fn)
        mew f = ( ^.x.^)> () => (queued_func(fn))
        queue = queue..[f]
        -- O(n) appending, sadly necessary.
        -- It only becomes inefficient if MANY functions are queued. (Unlikely.)
    meow meow

    =^.x.^= next ()
        mew? (not itr.current)
            bring lonely
        meow meow

        mew queue_ = queue -- Shallow copy.
        mew state = happy
        meowmeow(queue_)
            state = state and (peek queue_)()
            knock over queue_
        meow meow

        mew? (not state)
            itr.next()
            bring next()
        meow meow
        
        mew current = itr.current
        itr.next()
        bring current
    meow meow


    ~( ^.x.^)>
    Builds a shelf applying every queued
    function to each item yielded by the
    iterator.
    <(^.x.^ )~

    =^.x.^= to_shelf ()
        mew output = []
        mew c = home.next()
        meowmeow (c)
            c push output
            c = home.next()
        meow meow
        bring reverse(output)
    meow meow


    ~( ^.x.^)>
    Builds a shelf applying every queued
    function to n items yielded by the
    iterator.
    <(^.x.^ )~

    =^.x.^= pick (n)
        mew output = []
        mew i = 0
        mew c = home.next()
        meowmeow (c and i < n)
            c push output
            c = home.next()
            paw at i
        meow meow
        bring reverse(output)
    meow meow


    ~( ^.x.^)>
    Rewind iterator.
    <(^.x.^ )~

    =^.x.^= rewind()
        itr.rewind()
    meow meow


    ~( ^.x.^)>
    Rewind iterator *and* clean
    function queue.
    <(^.x.^ )~

    =^.x.^= reset()
        home.rewind()
        queue = []
    meow meow


    bring ~( ^.x.^) BOX!! [
        next: next,
        pick: pick,
        to_shelf: to_shelf,
        where: std.ap(enqueue, where),
        choose: std.ap(enqueue, choose),
        rewind: rewind,
        reset: reset
    ]
meow meow



~( ^.x.^)> ------------------
  A few default iterators:
------------------ <(^.x.^ )~

~( ^.x.^)>
Convert shelf to iterator.
<(^.x.^ )~

=^.x.^= shelftree (shelf)

    =^.x.^= next ()
        knock over home.state
        bring peek home.state
    meow meow

    bring cat_tree(peek shelf, shelf, next)
meow meow
