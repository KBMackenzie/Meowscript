~( ^.x.^)> -----------------------------------------------
An implementation of lazy sequence function application.

It's inspired by C#'s LINQ!

-- Cat Trees (Iterator) --
They provide an interface for interating over a collection
or otherwise iteratable object.

They contain three core items:
1. 'current'    -> The 'current' item.
2. 'next()'     -> A method that moves to the next item.
3. 'rewind()'   -> Rewinds the iterator to its initial state.

The cat_tree() function takes three arguments:
1. An initial state value.
2. A 'state' value. It can be anything.
3. An iterator function. It should return a value that'll
be used as the new 'current' value each time .next() is
called.

All of those arguments are deep-copied.

The iterator function can manipulate the home.state field
if it wishes.

The cat_tree() function produces a rewind() function behind
the scenes that sets home.current and home.state to the
1st and 2nd arguments passed to the function.



-- Scratchpost (Lazy Wrapper) --
Scratchpost provide an interface for lazily performing queued
operations over an iterator's values. 

Every call of '.where()', '.choose()' and other methods add
a new function to the bottom of the queue.

In each call of .step(), the scratchpost asks for another item
from the iterator and lazily applies the queued functions
to the item. When the iterator is out of items, iteration
ends, and .step() returns lonely.

**Note:** While iterators start at the first item and each
call of .next() moves them further along, a scratchpost
always starts *before* the first item. Thus, the first call
of .step() will give you the *first* element.

If all catfunctions return happy, the scratchpost returns the
item and stops. If not, the scratchpost asks for another item
and repeats the process.

The .to_shelf() method will always traverse the iterator's 
values only once, no matter how many functions are in the
queue.
**Note:** The .to_shelf() function **will hang** when given
an infinite iteratable.

The .pick(x) method will only ask for x items, no matter how
many items the iterator is able to produce. The functions in
the queue will, thus, only be applied to exactly x items.

The .rewind() method rewinds the iterator. It does **not**
clean the function queue.

The .reset() method rewinds the iterator *and* cleans the
scratchpost's function queue.


The scratchpost function takes one argument, an iterator box,
which it **always deep-copies.**
----------------------------------------------- <(^.x.^ )~

--takes "std.meows" as std

=^.x.^= cat_tree (init, state, iterator)

    =^.x.^= rewind ()
        home.state = copy(state)
        home.current = copy(init)
    meow meow

    =^.x.^= next ()
        home.current = home.iterator()
        bring home.current
    meow meow

    =^.x.^= to_shelf ()
        mew output = []
        meowmeow (home.current)
            home.current push output
            home.next()
        meow meow
        bring reverse(output)
    meow meow

    =^.x.^= pick (n)
        mew output = []
        mew i = 0
        meowmeow (home.current and i < n)
            home.current push output
            home.next()
            paw at i
        meow meow
        bring reverse(output)
    meow meow

    =^.x.^= skip (n)
        mew i = 0
        meowmeow (home.current and i < n)
            home.next()
            paw at i
        meow meow
    meow meow

    bring ~( ^.x.^) BOX!! [
        current:    copy(init),
        state:      copy(state),
        iterator:   copy(iterator),
        next:       next,
        rewind:     rewind,
        to_shelf:   to_shelf,
        pick:       pick,
        skip:       skip
    ]
meow meow


=^.x.^= scratchpost (i)

    mew queue = []
    mew itr = copy(i)

    =^.x.^= where (fn)
        bring itr.current and fn(itr.current)
    meow meow

    =^.x.^= choose (fn)
        mew? (not itr.current)
            bring sad
        meow meow
        itr.current = fn(itr.current)
        bring happy
    meow meow



    ~( ^.x.^)> ------------
           ENQUEUING 
    ------------ <(^.x.^ )~

    ~( ^.x.^)>
    O(n) appending, sadly necessary.
    It only becomes inefficient if MANY functions are queued. (Unlikely.)
    Return the box itself to allow for chained methods.
    <(^.x.^ )~

    =^.x.^= enqueue (queued_func, fn)
        mew f = ( ^.x.^)> () => (queued_func(fn))
        queue = queue..[f] 
    meow meow

    ~( ^.x.^)>
    Higher-order function wrapper around the
    'enqueue' function.
    <(^.x.^ )~

    =^.x.^= where_enq (fn)
        enqueue(where, fn)
        bring home
    meow meow

    =^.x.^= choose_enq (fn)
        enqueue(choose, fn)
        bring home
    meow meow


    ~( ^.x.^)> ------------
            STEPPING
    ------------ <(^.x.^ )~

    =^.x.^= step ()
        mew? (not itr.current)
            bring lonely
        meow meow

        mew queue_ = queue -- Shallow copy.
        mew state = happy
        meowmeow(queue_)
            state = state and (peek queue_)()
            knock over queue_
        meow meow

        mew? (not state)
            itr.next()
            bring step()
        meow meow
        
        mew current = itr.current
        itr.next()
        bring current
    meow meow


    ~( ^.x.^)>
    Builds a shelf applying every queued
    function to each item yielded by the
    iterator.
    <(^.x.^ )~

    =^.x.^= to_shelf ()
        mew output = []
        mew c = home.step()
        meowmeow (c)
            c push output
            c = home.step()
        meow meow
        bring reverse(output)
    meow meow


    ~( ^.x.^)>
    Builds a shelf applying every queued
    function to n items yielded by the
    iterator.
    <(^.x.^ )~

    =^.x.^= pick (n)
        mew output = []
        mew i = 0
        mew c = home.step()
        meowmeow (c and i < n)
            c push output
            c = home.step()
            paw at i
        meow meow
        bring reverse(output)
    meow meow


    ~( ^.x.^)>
    Skips n items, moving the iterator
    state forward.

    It returns home to allow for using
    it in chained method calls.

    It's *not* a queued operation, however.
    <(^.x.^ )~

    =^.x.^= skip (n)
        mew i = 0
        meowmeow (c and i < n)
            c = home.step()
            paw at i
        meow meow
        bring home
    meow meow


    ~( ^.x.^)>
    Rewind iterator.
    <(^.x.^ )~

    =^.x.^= rewind()
        itr.rewind()
    meow meow


    ~( ^.x.^)>
    Rewind iterator *and* clean
    function queue.
    <(^.x.^ )~

    =^.x.^= reset()
        home.rewind()
        queue = []
    meow meow


    bring ~( ^.x.^) BOX!! [
        step: step,
        pick: pick,
        skip: skip,
        to_shelf: to_shelf,
        where: where_enq,
        choose: choose_enq,
        rewind: rewind,
        reset: reset
    ]
meow meow



~( ^.x.^)> ------------------
  A few default iterators:
------------------ <(^.x.^ )~

~( ^.x.^)>
Convert shelf to a scratchpost, allowing for
lazy computations on list values. THe shelf
itself generates an iterator behind the scenes.
<(^.x.^ )~

=^.x.^= highshelf (shelf)

    =^.x.^= next ()
        knock over home.state
        bring peek home.state
    meow meow

    mew iter = cat_tree(peek shelf, shelf, next)
    bring scratchpost(iter)
meow meow



