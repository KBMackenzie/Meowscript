-- std.meows

------------------------------------------------
-- Operator functions
------------------------------------------------

-- Arithmetic operations
add = ( ^.x.^)> (a, b) => (a + b)
sub = ( ^.x.^)> (a, b) => (a - b)
mul = ( ^.x.^)> (a, b) => (a * b)
div = ( ^.x.^)> (a, b) => (a / b)
mod = ( ^.x.^)> (a, b) => (a % b)

pow = ( ^.x.^)> (a, b) => (a ^ b)
sqr = ( ^.x.^)> (a) => (a ^ 2)

min = ( ^.x.^)> (a, b) => (a < b ? a : b)
max = ( ^.x.^)> (a, b) => (a > b ? a : b)

-- String/shelf join
join = ( ^.x.^)> (a, b) => (a..b)

-- String/shelf length
length = ( ^.x.^)> (a) => (a?!)

-- Comparison 

compare = ~( ^.x.^) BOX!! [
    equal:   ( ^.x.^)> (a, b) => (a == b),
    lesser:  ( ^.x.^)> (a, b) => (a < b),
    greater: ( ^.x.^)> (a, b) => (a > b),
    lesser_or_equal:  ( ^.x.^)> (a, b) => (a <= b),
    greater_or_equal: ( ^.x.^)> (a, b) => (a >= b)
]

-- Integer division
int_div = ( ^.x.^)> (a, b) => (floor(a / b))


------------------------------------------------
-- Assert (debugging)
------------------------------------------------

assert = ( ^.x.^)> (a) => (a or throw("Assertion failed."))


------------------------------------------------
-- Random
------------------------------------------------

-- Random float in range.
-- 'max' is not inclusive.
=^.x.^= random_range(min, max)
    bring random() * (max - min) + min
meow meow

-- Random float between 0 and num.
-- 'num' is not inclusive.
=^.x.^= random_until(num)
    bring random() * num
meow meow

-- Random int in range.
-- 'max' is inclusive.
=^.x.^= random_int(min, max)
    bring round(random_range(min, max))
meow meow


------------------------------------------------
-- Stack/shelf functions
------------------------------------------------

-- Map implementation.
-- Callback function should take one argument.

=^.x.^= map (shelf, fn)
    mew output = []
    meowmeow (shelf)
        fn(peek shelf) push output
        knock over shelf
    meow meow
    bring reverse(output) -- Reverse because stack.
meow meow


-- Foldl implementation.
-- Callback function should take two arguments!

=^.x.^= fold (shelf, fn, init)
    mew output = init
    meowmeow (shelf)
        output = fn(output, peek shelf)
        knock over shelf
    meow meow
    bring output
meow meow


-- Filter implementation.
-- Callback should take one argument.

=^.x.^= filter (shelf, fn)
    mew output = []
    meowmeow (shelf)
        mew item = peek shelf
        mew? (fn(item))
            item push output
        meow meow
        knock over shelf
    meow meow
    bring reverse(output) -- Reversing because stack.
meow meow


-- 'Contains' function.
-- Checks if an item exists in the shelf.
=^.x.^= contains (shelf, item)
    meowmeow (shelf)
        mew? (peek shelf == item)
            bring happy
        meow meow
        knock over shelf
    meow meow
    bring sad
meow meow

-- 'Any' function.
-- Checks if any item in the shelf satisfies a condition.
=^.x.^= any (shelf, fn)
    meowmeow (shelf)
        mew? (fn(peek shelf))
            bring happy
        meow meow
        knock over shelf
    meow meow
    bring sad
meow meow

-- 'All' function.
-- Checks if all items in the shelf satisfy a condition.
=^.x.^= all (shelf, fn)
    meowmeow (shelf)
        mew? (not fn(peek shelf))
            bring sad
        meow meow
        knock over shelf
    meow meow
    bring happy
meow meow

------------------------------------------------
-- Additional stack/shelf functions
------------------------------------------------

-- Indexing function implementation.
-- It's O(n) and highly discouraged, because shelves!

-- Note this function does not throw exceptions when an
-- index goes out of bounds, because of how
-- knocking over items from shelves works in Meowscript.
-- It returns 'lonely' instead.

=^.x.^= index (shelf, num)
    take (mew i = 0) and do (paw at i) while (i < num)
        knock over shelf
    meow meow 
    bring peek shelf
meow meow


-- 'Take' function implementation.
-- Takes n items from a shelf and returns a list of items.

=^.x.^= take_n (shelf, n)
    mew output = []
    take (mew i = 0) and do (paw at i) while (i < n)
        (peek shelf) push output
        knock over shelf
    meow meow
    bring reverse(output) -- Reversing because stack.
meow meow


-- 'Drop' function implementation.
-- Drops n items from a shself and returns the shelf.

=^.x.^= drop_n (shelf, n)
    mew output = []
    take (mew i = 0) and do (paw at i) while (i < n)
        knock over shelf
    meow meow
    bring shelf
meow meow


-- 'Take while' function implementation.
-- Takes items while the top of the shelf satisfies the predicate.

=^.x.^= take_while (shelf, fn)
    mew output = []
    meowmeow (fn(peek shelf))
        (peek shelf) push output
        knock over shelf
    meow meow
    bring reverse(output) -- Reversing because stack.
meow meow


-- 'Drop while' function implementation.
-- Drops items while the top of the shelf satisfies the predicate.

=^.x.^= drop_while (shelf, fn)
    meowmeow (fn(peek shelf))
        knock over shelf
    meow meow
    bring shelf
meow meow



------------------------------------------------
-- String functions
------------------------------------------------

-- Flatten a shelf into a string.
-- It uses a fold, because yay!

=^.x.^= concat_as_str (shelf)
    bring fold (shelf, join, "")
meow meow


-- Substring function implemetation.
-- It's not good for very long strings.

=^.x.^= substring (str, start, length)
    mew output = drop_n(str, start) -- Start at specified index.
    output = take_n(output, length) -- Take length.
    bring concat_as_str(output) -- Flatten list into string.
meow meow


-- 'Trim' function implemntation!
-- Trims whitespace from both ends of a string.

=^.x.^= trim (str)
    mew fn = ( ^.x.^)> (x) => (x == " ")
    str = drop_while(str, fn)
    str = drop_while(reverse(str), fn)
    bring reverse(str) -- Reversing again.
meow meow


------------------------------------------------
-- Dictionary
------------------------------------------------

=^.x.^= dictionary()
    bring ~( ^.x.^) BOX!! [
        _pairs: ~( ^.x.^) BOX!! [],
        length:   ( ^.x.^)> () => (home._pairs?!),
        keys:     ( ^.x.^)> () => (keys(home._pairs)),
        values:   ( ^.x.^)> () => (values(home._pairs)),
        add:      ( ^.x.^)> (key, value) => (home._pairs.~~(string(key)) = value),
        get:      ( ^.x.^)> (key) => (home._pairs.~~(string(key))),
        contains: ( ^.x.^)> (key) => (contains(home.keys(), string(key)))
    ]
meow meow

------------------------------------------------
-- Partial function application
------------------------------------------------

-- Flip a function's arguments.
-- Accepts only (a -> b -> c) functions.
=^.x.^= flip (fn)
    bring ( ^.x.^)> (a, b) => (fn(b, a))
meow meow

-- Takes an (a -> b -> c) function and makes it a (b -> c).
=^.x.^= partial (fn, a)
    bring ( ^.x.^)> (b) => (fn(a, b))
meow meow

-- Takes an (a -> b -> c -> d) function and makes it (b -> c -> d).
=^.x.^= partial2 (fn, a)
    bring ( ^.x.^)> (b, c) => (fn(a, b, c))
meow meow

-- Takes an (a -> b -> c -> d -> e) function and amkes it (b -> c -> d -> e).
=^.x.^= partial3 (fn, a)
    bring ( ^.x.^)> (b, c, d) => (fn(a, b, c, d))
meow meow



-- TESTS

-- Increment map (success!)
--bring map ([1, 2, 3], ( ^.x.^)> (x) => (x + 1))

-- Sum fold (success!)
--bring fold ([1, 2, 3, 10, 20], ( ^.x.^)> (x, y) => (x + y), 0)

-- Filter odd numbers (success!)
-- bring filter ([1, 2, 3, 4], ( ^.x.^)> (x) => (x % 2 == 0))

-- Index shelf (O(n)) (success!)
-- bring index ([1, 2, 3], 2)

-- Take n (success!)
-- bring take_n ([1, 2, 3], 3)

-- Drop n (success!)
-- bring drop_n ([1, 2, 3], 2)

-- Substring fn (success!)
-- bring substring("hello world", 0, 5)

-- Take while (success!)
-- bring take_while ([2, 4, 3], ( ^.x.^)> (x) => (x % 2 == 0))

-- Drop while (success!)
-- bring drop_while ([2, 4, 3], ( ^.x.^)> (x) => (x % 2 == 0))

-- Trim str (success!)
-- bring trim("    meow    ")

-- throw("><")
